# Функции

1. у стрелочных функций нет собственного this
1. нет и своего объекта arguments.
1. When ...arr is used in the function call, it “expands” an iterable object arr into the list of arguments.
    Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.
    ```let arr = [3, 5, 1];
    alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
    ```
1. Rest parameters ...
    Rest parameters могут быть обозначены через три точки `...`. Буквально это значит: «собери оставшиеся параметры и положи их в массив».
1. Функция-конструктор должна вызываться при помощи оператора `new`.
    ```
   function User(name) {
     // this = {};  (неявно)
     this.name = name;
     // return this;  (неявно)
     // return { name: "Godzilla" };  // <-- возвращает этот объект, если указать явно объект (с примитивами вернется this) 
   }
   let user = new User("Вася");
   alert(user.name); // Вася 
   ```
   Когда функция вызывается как new User(...), происходит следующее:
   
   1. **Создаётся новый пустой объект, и он присваивается this.**
   1. Выполняется код функции. Обычно он модифицирует `this`, добавляет туда новые свойства.
   1. Возвращается значение `this`.
1. Каждая функция может быть вызвана при помощи оператора new
    ```
   let user = new function() {
      this.name = "Вася";
   };
   ```
   Такой конструктор не может быть вызван дважды, так как он нигде не сохраняется, просто создаётся и тут же вызывается. 
   Таким образом, такой метод создания позволяет инкапсулировать код, который создаёт отдельный объект, но без возможности его повторного использования.
1. В случае, если функция вызвана при помощи `new`, то в `new.target` будет сама функция, в противном случае `undefined`.
1. Можно не ставить скобки после `new`, если вызов конструктора идёт без аргументов: `let user = new User;`
1. Примитивы передаются в функцию (аргументы функции) по значнию, а объекты по ссылке (объекты, массивы)
   НО! для объектов и массивов изменить можно только внутренние свойства и методы, нельзя присвоить новый объект или массив
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
